--- a/libphobos/libdruntime/core/sys/posix/pthread.d
+++ b/libphobos/libdruntime/core/sys/posix/pthread.d
@@ -30,6 +30,113 @@
 else version (WatchOS)
     version = Darwin;
 
+version (MinGW)
+{
+    extern (C) nothrow:
+
+    // winpthreads initializers: GENERIC_INITIALIZER = -1, PTHREAD_ONCE_INIT = 0
+    enum PTHREAD_MUTEX_INITIALIZER  = cast(pthread_mutex_t)-1;
+    enum PTHREAD_COND_INITIALIZER   = cast(pthread_cond_t)-1;
+    enum PTHREAD_RWLOCK_INITIALIZER = cast(pthread_rwlock_t)-1;
+    enum PTHREAD_ONCE_INIT          = 0;
+
+    enum
+    {
+        PTHREAD_CREATE_JOINABLE = 0,
+        PTHREAD_CREATE_DETACHED = 1
+    }
+
+    enum
+    {
+        PTHREAD_INHERIT_SCHED  = 0,
+        PTHREAD_EXPLICIT_SCHED = 1
+    }
+
+    enum
+    {
+        PTHREAD_PROCESS_PRIVATE = 0,
+        PTHREAD_PROCESS_SHARED  = 1
+    }
+
+    // pthread function declarations  
+    @nogc {
+        int pthread_attr_destroy(pthread_attr_t*);
+        int pthread_attr_getdetachstate(const scope pthread_attr_t*, int*);
+        int pthread_attr_getschedparam(const scope pthread_attr_t*, sched_param*);
+        int pthread_attr_init(pthread_attr_t*);
+        int pthread_attr_setdetachstate(pthread_attr_t*, int);
+        int pthread_attr_setschedparam(const scope pthread_attr_t*, sched_param*);
+        int pthread_cancel(pthread_t);
+        int pthread_cond_broadcast(pthread_cond_t*);
+        int pthread_cond_destroy(pthread_cond_t*);
+        int pthread_cond_init(const scope pthread_cond_t*, pthread_condattr_t*);
+        int pthread_cond_signal(pthread_cond_t*);
+        int pthread_cond_timedwait(pthread_cond_t*, pthread_mutex_t*, const scope timespec*);
+        int pthread_cond_wait(pthread_cond_t*, pthread_mutex_t*);
+        int pthread_condattr_destroy(pthread_condattr_t*);
+        int pthread_condattr_init(pthread_condattr_t*);
+        int pthread_create(pthread_t*, const scope pthread_attr_t*, void* function(void*), void*);
+        int pthread_detach(pthread_t);
+        int pthread_equal(pthread_t, pthread_t);
+        void pthread_exit(void*);
+        void* pthread_getspecific(pthread_key_t);
+        int pthread_join(pthread_t, void**);
+        int pthread_key_create(pthread_key_t*, void function(void*));
+        int pthread_key_delete(pthread_key_t);
+        int pthread_mutex_destroy(pthread_mutex_t*);
+        int pthread_mutex_init(pthread_mutex_t*, pthread_mutexattr_t*);
+        int pthread_mutex_lock(pthread_mutex_t*);
+        int pthread_mutex_trylock(pthread_mutex_t*);
+        int pthread_mutex_unlock(pthread_mutex_t*);
+        int pthread_mutexattr_destroy(pthread_mutexattr_t*);
+        int pthread_mutexattr_init(pthread_mutexattr_t*);
+        int pthread_once(pthread_once_t*, void function());
+        int pthread_rwlock_destroy(pthread_rwlock_t*);
+        int pthread_rwlock_init(pthread_rwlock_t*, const scope pthread_rwlockattr_t*);
+        int pthread_rwlock_rdlock(pthread_rwlock_t*);
+        int pthread_rwlock_tryrdlock(pthread_rwlock_t*);
+        int pthread_rwlock_trywrlock(pthread_rwlock_t*);
+        int pthread_rwlock_unlock(pthread_rwlock_t*);
+        int pthread_rwlock_wrlock(pthread_rwlock_t*);
+        int pthread_rwlockattr_destroy(pthread_rwlockattr_t*);
+        int pthread_rwlockattr_init(pthread_rwlockattr_t*);
+        pthread_t pthread_self();
+        int pthread_setcancelstate(int, int*);
+        int pthread_setcanceltype(int, int*);
+        int pthread_setspecific(pthread_key_t, const scope void*);
+        void pthread_testcancel();
+    }
+
+    // Thread-Specific Storage (TSS)
+    enum PTHREAD_DESTRUCTOR_ITERATIONS = 4;
+
+    // Mutexes
+    enum
+    {
+        PTHREAD_MUTEX_NORMAL = 0,
+        PTHREAD_MUTEX_ERRORCHECK = 1,
+        PTHREAD_MUTEX_RECURSIVE = 2,
+        PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
+    }
+
+    int pthread_mutexattr_gettype(const scope pthread_mutexattr_t*, int*);
+    int pthread_mutexattr_settype(pthread_mutexattr_t*, int);
+
+    // Barrier
+    struct pthread_barrier_t
+    {
+        ptrdiff_t ptr;  // intptr_t
+        uint count;     // unsigned
+    }
+
+    alias pthread_barrierattr_t = int;
+    enum PTHREAD_BARRIER_SERIAL_THREAD = 1;
+
+    int pthread_barrier_destroy(pthread_barrier_t*);
+    int pthread_barrier_init(pthread_barrier_t*, const scope pthread_barrierattr_t*, uint);
+    int pthread_barrier_wait(pthread_barrier_t*);
+}
+else
 version (Posix):
 extern (C)
 nothrow:
--- a/libphobos/libdruntime/core/sys/posix/sys/types.d
+++ b/libphobos/libdruntime/core/sys/posix/sys/types.d
@@ -28,6 +28,48 @@
 else version (WatchOS)
     version = Darwin;
 
+version (MinGW)
+{
+    extern (C):
+
+    // Basic types
+    alias c_long time_t;  // __time64_t on 64-bit MinGW
+
+    // Basic time types
+    struct timespec
+    {
+        time_t tv_sec;   // seconds
+        c_long tv_nsec;  // nanoseconds
+    }
+
+    // Scheduling parameter
+    struct sched_param
+    {
+        int sched_priority;
+    }
+
+    // winpthreads types
+    alias size_t pthread_t;        // uintptr_t
+    alias uint pthread_key_t;      // unsigned
+    alias c_long pthread_once_t;   // long
+    
+    struct pthread_attr_t {
+        uint p_state;
+        void* stack;
+        size_t s_size;
+        sched_param param;
+    }
+    
+    alias ptrdiff_t pthread_mutex_t;      // intptr_t
+    alias uint pthread_mutexattr_t;       // unsigned
+    
+    alias ptrdiff_t pthread_cond_t;       // intptr_t
+    alias int pthread_condattr_t;         // int
+    
+    alias ptrdiff_t pthread_rwlock_t;     // intptr_t
+    alias int pthread_rwlockattr_t;       // int
+}
+else
 version (Posix):
 extern (C):
 
